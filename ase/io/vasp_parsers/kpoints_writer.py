from dataclasses import dataclass
from typing import Union, List

from ase.dft.kpoints import BandPath, WeightedKPoints, RegularGridKPoints
from pathlib import Path


@dataclass
class _State:
    number_kpoints: int = 0
    mode: Union[str, None] = None
    coordinate: Union[str, None] = None
    specification: Union[List[str], None] = None


def write_kpoints(directory, parameters):
    if isinstance(parameters, str):
        kpoints_str = parameters
    elif isinstance(parameters, list):
        state = _State()
        update_state(state, "Gamma", parameters)
        kpoints_str = "\n".join(prepare_lines(state))
    elif parameters is None:
        return
    else:
        state = _State()
        for item in parameters.items():
            state = update_state(state, *item)
        kpoints_str = "\n".join(prepare_lines(state))
    with open(f"{directory}/KPOINTS", "w") as kpoints:
        kpoints.write(kpoints_str)


def update_state(state, key, value):
    key = key.capitalize()
    if key == "Auto":
        state.mode = key
        state.specification = [str(value)]
    elif key in ("Gamma", "Monkhorst"):
        state.mode = key
        state.specification = [" ".join(str(x) for x in value)]
    elif key == "Line":
        state.mode = key
        state.number_kpoints = value
    elif key in ("Reciprocal", "Cartesian"):
        if state.number_kpoints == 0:
            state.number_kpoints = len(value)
        state.coordinate = key
        state.specification = [" ".join(str(x) for x in kpt) for kpt in value]
    else:
        raise NotImplementedError
    return state


def prepare_lines(state):
    yield "KPOINTS created by Atomic Simulation Environment"
    yield str(state.number_kpoints)
    if state.mode is not None:
        yield state.mode
    if state.coordinate is not None:
        yield state.coordinate
    for line in state.specification:
        yield line

def write_kpoints_file(kpoints_str: str, directory: Union[str, Path]) -> None:
        with open(f"{directory}/KPOINTS", "w") as kpoints:
            kpoints.write(kpoints_str)

#Class that produces KPOINTS files based on WeightedKPoints, RegularGridKPoints, and BandPath objects.
#The KPOINTS file is written to the directory specified in the write_kpoints method.
class KPointsWriter:
    """
    Class that produces KPOINTS files based on WeightedKPoints, RegularGridKPoints, and BandPath objects.
    The KPOINTS file is written to the directory specified in the write_kpoints method.
    """
    def __init__(self,
                 kpoints: Union[RegularGridKPoints, WeightedKPoints, BandPath],
                 force_gamma: bool=False) -> None:
        """
        Parameters
        ----------
        kpoints : WeightedKPoints, RegularGridKPoints, or BandPath
            The kpoints object to be written to the KPOINTS file.
        force_gamma : bool
            If True, the KPOINTS file will be written with the Gamma centering.
            If False, the KPOINTS file will be written with the Monkhorst-Pack centering.
        """
        self.kpoints = kpoints
        self.force_gamma = force_gamma

    def write_kpoints(self, directory: Union[str, Path]) -> None:
        if isinstance(self.kpoints, WeightedKPoints):
            kpoints_str = self._generate_weighted_kpoints_file(self.kpoints)
        elif isinstance(self.kpoints, RegularGridKPoints):
            kpoints_str = self._generate_regular_grid_kpoints_file(self.kpoints)
        elif isinstance(self.kpoints, BandPath):
            kpoints_str = self._generate_bandpath_file(self.kpoints)
        else:
            raise NotImplementedError
        write_kpoints_file(kpoints_str, directory)

    def _generate_weighted_kpoints_file(self, kpoints: WeightedKPoints) -> str:
        kpoints_str = "Explicit kpoints list generated by ASE\n"
        kpoints_str += f"{len(kpoints.kpts)}\n"
        kpoints_str += "Direct\n"
        for kpt, weight in zip(kpoints.kpts, kpoints.weights):
            kpoints_str += f"{kpt[0]:.7f}  {kpt[1]:.7f}  {kpt[2]:.7f}  {weight:.5f}\n"
        return kpoints_str
    
    def _generate_regular_grid_kpoints_file(self, kpoints: RegularGridKPoints) -> str:
        kpoints_str = "Regular grid of kpoints generated by ASE\n"
        kpoints_str += "0\n"
        if self.force_gamma:
            kpoints_str += "Gamma\n"
            kpoints_str += f"{kpoints.size[0]} {kpoints.size[1]} {kpoints.size[2]}\n"
        else:
            kpoints_str += "Monkhorst-Pack\n"
            kpoints_str += f"{kpoints.size[0]} {kpoints.size[1]} {kpoints.size[2]}\n"
            kpoints_str += f"{kpoints.offset[0]} {kpoints.offset[1]} {kpoints.offset[2]}"
        return kpoints_str

    def _generate_bandpath_file(self, bandpath: BandPath) -> str:

        # The following code writes a KPOINTS file for a band structure calculation
        # using VASPs line mode. However, this format is crashing ASEs xml parser.
        # Therefore, we use the exoplicit kpoints list format instead.
        #-----------------------------------------------------------------------------
        # points_per_line = len(bandpath.kpts) // (len(bandpath.path) - 1)
        # kpoints_str = "kpoints along high symmetry lines generated by ASE\n"
        # kpoints_str += f"{points_per_line}   !Nr. of points per line\n"
        # kpoints_str += "Line mode\n"
        # kpoints_str += "Fractional\n"
        # for i in range(len(bandpath.path) - 1):
        #     c0 = bandpath.path[i]
        #     c1 = bandpath.path[i + 1]
        #     if "," not in (c0, c1):
        #         p0 = bandpath.special_points[c0]
        #         p1 = bandpath.special_points[c1]
        #         # print special points without the brackets and the commas:
        #         kpoints_str += (
        #             f"{p0[0]:.7f}  {p0[1]:.7f}  {p0[2]:.7f}   {c0}\n"
        #             f"{p1[0]:.7f}  {p1[1]:.7f}  {p1[2]:.7f}   {c1}\n\n")
        # return kpoints_str
        #-----------------------------------------------------------------------------
        import numpy as np
        kpoints_str = "Explicit kpoints list for bandstructure generated by ASE\n"
        kpoints_str += f"{len(bandpath.kpts)}\n"
        kpoints_str += "Fractional\n"
        weights = np.ones(len(bandpath.kpts))
        for kpt, weight in zip(bandpath.kpts, weights):
            kpoints_str += f"{kpt[0]:.7f}  {kpt[1]:.7f}  {kpt[2]:.7f}  {weight:.1f}\n"
        return kpoints_str

if __name__ == "__main__":
    from ase.build import bulk
    import numpy as np
    atoms = bulk('Si', crystalstructure='fcc', a=3.9)
    bandpath = atoms.cell.bandpath()
    kpoints_writer = KPointsWriter(bandpath)
    kpoints_writer.write_kpoints('.')
    reg_kpoints = RegularGridKPoints([5, 5, 5], offset=(0.5, 0.5, 0.5))
    weighted_kpoints = WeightedKPoints(reg_kpoints.kpts, weights=np.ones(len(reg_kpoints.kpts)))
    kpoints_writer = KPointsWriter(reg_kpoints, force_gamma=True)
    kpoints_writer.write_kpoints('.')